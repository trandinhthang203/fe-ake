{"version":3,"file":"dist-CHdgg282.js","names":["React","React","React","useLayoutEffect"],"sources":["../../@radix-ui/react-id/dist/index.mjs","../../@radix-ui/react-use-effect-event/dist/index.mjs","../../@radix-ui/react-use-controllable-state/dist/index.mjs"],"sourcesContent":["// packages/react/id/src/id.tsx\nimport * as React from \"react\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nvar useReactId = React[\" useId \".trim().toString()] || (() => void 0);\nvar count = 0;\nfunction useId(deterministicId) {\n  const [id, setId] = React.useState(useReactId());\n  useLayoutEffect(() => {\n    if (!deterministicId) setId((reactId) => reactId ?? String(count++));\n  }, [deterministicId]);\n  return deterministicId || (id ? `radix-${id}` : \"\");\n}\nexport {\n  useId\n};\n//# sourceMappingURL=index.mjs.map\n","// src/use-effect-event.tsx\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport * as React from \"react\";\nvar useReactEffectEvent = React[\" useEffectEvent \".trim().toString()];\nvar useReactInsertionEffect = React[\" useInsertionEffect \".trim().toString()];\nfunction useEffectEvent(callback) {\n  if (typeof useReactEffectEvent === \"function\") {\n    return useReactEffectEvent(callback);\n  }\n  const ref = React.useRef(() => {\n    throw new Error(\"Cannot call an event handler while rendering.\");\n  });\n  if (typeof useReactInsertionEffect === \"function\") {\n    useReactInsertionEffect(() => {\n      ref.current = callback;\n    });\n  } else {\n    useLayoutEffect(() => {\n      ref.current = callback;\n    });\n  }\n  return React.useMemo(() => (...args) => ref.current?.(...args), []);\n}\nexport {\n  useEffectEvent\n};\n//# sourceMappingURL=index.mjs.map\n","// src/use-controllable-state.tsx\nimport * as React from \"react\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nvar useInsertionEffect = React[\" useInsertionEffect \".trim().toString()] || useLayoutEffect;\nfunction useControllableState({\n  prop,\n  defaultProp,\n  onChange = () => {\n  },\n  caller\n}) {\n  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({\n    defaultProp,\n    onChange\n  });\n  const isControlled = prop !== void 0;\n  const value = isControlled ? prop : uncontrolledProp;\n  if (true) {\n    const isControlledRef = React.useRef(prop !== void 0);\n    React.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? \"controlled\" : \"uncontrolled\";\n        const to = isControlled ? \"controlled\" : \"uncontrolled\";\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  const setValue = React.useCallback(\n    (nextValue) => {\n      if (isControlled) {\n        const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;\n        if (value2 !== prop) {\n          onChangeRef.current?.(value2);\n        }\n      } else {\n        setUncontrolledProp(nextValue);\n      }\n    },\n    [isControlled, prop, setUncontrolledProp, onChangeRef]\n  );\n  return [value, setValue];\n}\nfunction useUncontrolledState({\n  defaultProp,\n  onChange\n}) {\n  const [value, setValue] = React.useState(defaultProp);\n  const prevValueRef = React.useRef(value);\n  const onChangeRef = React.useRef(onChange);\n  useInsertionEffect(() => {\n    onChangeRef.current = onChange;\n  }, [onChange]);\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      onChangeRef.current?.(value);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef]);\n  return [value, setValue, onChangeRef];\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n\n// src/use-controllable-state-reducer.tsx\nimport * as React2 from \"react\";\nimport { useEffectEvent } from \"@radix-ui/react-use-effect-event\";\nvar SYNC_STATE = Symbol(\"RADIX:SYNC_STATE\");\nfunction useControllableStateReducer(reducer, userArgs, initialArg, init) {\n  const { prop: controlledState, defaultProp, onChange: onChangeProp, caller } = userArgs;\n  const isControlled = controlledState !== void 0;\n  const onChange = useEffectEvent(onChangeProp);\n  if (true) {\n    const isControlledRef = React2.useRef(controlledState !== void 0);\n    React2.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? \"controlled\" : \"uncontrolled\";\n        const to = isControlled ? \"controlled\" : \"uncontrolled\";\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  const args = [{ ...initialArg, state: defaultProp }];\n  if (init) {\n    args.push(init);\n  }\n  const [internalState, dispatch] = React2.useReducer(\n    (state2, action) => {\n      if (action.type === SYNC_STATE) {\n        return { ...state2, state: action.state };\n      }\n      const next = reducer(state2, action);\n      if (isControlled && !Object.is(next.state, state2.state)) {\n        onChange(next.state);\n      }\n      return next;\n    },\n    ...args\n  );\n  const uncontrolledState = internalState.state;\n  const prevValueRef = React2.useRef(uncontrolledState);\n  React2.useEffect(() => {\n    if (prevValueRef.current !== uncontrolledState) {\n      prevValueRef.current = uncontrolledState;\n      if (!isControlled) {\n        onChange(uncontrolledState);\n      }\n    }\n  }, [onChange, uncontrolledState, prevValueRef, isControlled]);\n  const state = React2.useMemo(() => {\n    const isControlled2 = controlledState !== void 0;\n    if (isControlled2) {\n      return { ...internalState, state: controlledState };\n    }\n    return internalState;\n  }, [internalState, controlledState]);\n  React2.useEffect(() => {\n    if (isControlled && !Object.is(controlledState, internalState.state)) {\n      dispatch({ type: SYNC_STATE, state: controlledState });\n    }\n  }, [controlledState, internalState.state, isControlled]);\n  return [state, dispatch];\n}\nexport {\n  useControllableState,\n  useControllableStateReducer\n};\n//# sourceMappingURL=index.mjs.map\n"],"mappings":";;;;;;AAGA,IAAI,aAAaA,aAAM,UAAU,MAAM,CAAC,UAAU,YAAY,KAAK;AACnE,IAAI,QAAQ;AACZ,SAAS,MAAM,iBAAiB;CAC9B,MAAM,CAAC,IAAI,sBAAe,SAAS,YAAY,CAAC;AAChD,wBAAsB;AACpB,MAAI,CAAC,gBAAiB,QAAO,YAAY,WAAW,OAAO,QAAQ,CAAC;IACnE,CAAC,gBAAgB,CAAC;AACrB,QAAO,oBAAoB,KAAK,SAAS,OAAO;;;;;ACPlD,IAAI,sBAAsBC,aAAM,mBAAmB,MAAM,CAAC,UAAU;AACpE,IAAI,0BAA0BA,aAAM,uBAAuB,MAAM,CAAC,UAAU;;;;ACD5E,IAAI,qBAAqBC,aAAM,uBAAuB,MAAM,CAAC,UAAU,KAAKC;AAC5E,SAAS,qBAAqB,EAC5B,MACA,aACA,iBAAiB,IAEjB,UACC;CACD,MAAM,CAAC,kBAAkB,qBAAqB,eAAe,qBAAqB;EAChF;EACA;EACD,CAAC;CACF,MAAM,eAAe,SAAS,KAAK;CACnC,MAAM,QAAQ,eAAe,OAAO;CAC1B;EACR,MAAM,+BAAwB,OAAO,SAAS,KAAK,EAAE;AACrD,eAAM,gBAAgB;GACpB,MAAM,gBAAgB,gBAAgB;AACtC,OAAI,kBAAkB,cAAc;IAClC,MAAM,OAAO,gBAAgB,eAAe;IAC5C,MAAM,KAAK,eAAe,eAAe;AACzC,YAAQ,KACN,GAAG,OAAO,oBAAoB,KAAK,MAAM,GAAG,4KAC7C;;AAEH,mBAAgB,UAAU;KACzB,CAAC,cAAc,OAAO,CAAC;;AAe5B,QAAO,CAAC,oBAbe,aACpB,cAAc;AACb,MAAI,cAAc;GAChB,MAAM,SAAS,WAAW,UAAU,GAAG,UAAU,KAAK,GAAG;AACzD,OAAI,WAAW,KACb,aAAY,UAAU,OAAO;QAG/B,qBAAoB,UAAU;IAGlC;EAAC;EAAc;EAAM;EAAqB;EAAY,CACvD,CACuB;;AAE1B,SAAS,qBAAqB,EAC5B,aACA,YACC;CACD,MAAM,CAAC,OAAO,yBAAkB,SAAS,YAAY;CACrD,MAAM,4BAAqB,OAAO,MAAM;CACxC,MAAM,2BAAoB,OAAO,SAAS;AAC1C,0BAAyB;AACvB,cAAY,UAAU;IACrB,CAAC,SAAS,CAAC;AACd,cAAM,gBAAgB;AACpB,MAAI,aAAa,YAAY,OAAO;AAClC,eAAY,UAAU,MAAM;AAC5B,gBAAa,UAAU;;IAExB,CAAC,OAAO,aAAa,CAAC;AACzB,QAAO;EAAC;EAAO;EAAU;EAAY;;AAEvC,SAAS,WAAW,OAAO;AACzB,QAAO,OAAO,UAAU"}